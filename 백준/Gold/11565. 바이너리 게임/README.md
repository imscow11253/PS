# [Gold II] 바이너리 게임 - 11565 

[문제 링크](https://www.acmicpc.net/problem/11565) 

### 성능 요약

메모리: 2024 KB, 시간: 0 ms

### 분류

애드 혹

### 제출 일자

2024년 9월 10일 11:26:12

### 문제 설명

<p>준민이는 세계적인 프로그래머 백준이, 선영이와 함께 낚시를 즐기고 있었다. 3시간 동안 고기가 낚이지 않자, 지루함을 느낀 그들은 준민이를 놀리기 위해 바이너리 게임을 시작했다! 게임의 룰은 다음과 같다.</p>

<p>먼저 백준이와 선영이는 0과 1로만 이루어진 문자열 a, b를 만들어 준민이에게 준다. 준민이는 받은 문자열 a를 b로 변형시켜야 승리하는데, 변형은 다음의 2개의 연산을 여러 번 반복하여 사용하는 식으로 이루어진다.</p>

<ul>
	<li>문자열 a의 맨 앞에 있는 문자를 뺄 수 있다. 예를 들어, (1001 → 001)이 가능하다. a가 빈 문자열이면 더 이상 뺄 수 없다.</li>
	<li>문자열 a의 맨 끝에 parity(a)를 추가할 수 있다. 예를 들어, (1000 → 10001)이 가능하다. parity(a)는 문자열 a에 들어있는 1의 개수가 홀수개이면 1이고, 나머지 경우에는 0이다.</li>
</ul>

<p>게임을 잘 못하는 준민이는 당신에게 게임의 승리 가능 여부를 물어봤다. 프로그래밍을 잘하는 당신은 불쌍한 준민이를 위해, binary string (0과 1로 이루어진 문자열) a, b를 보고 준민이의 승리 가능성을 알려주는 프로그램을 작성하려 한다.</p>

### 입력 

 <p>첫 번째 줄에는 문자열 a, 두 번째 줄에는 문자열 b가 주어진다. 두 문자열은 0과 1로만 이루어져 있으며, 문자열 a와 문자열 b의 길이는 1 이상 1,000 이하이다.</p>

### 출력 

 <p>준민이가 승리할 수 있으면 VICTORY, 아니면 DEFEAT를 출력한다.</p>

 ### 풀이 

 <p>최근에 골드 문제들을 풀면서 한 번에 못풀었던 적이 많았다. 이 알고리즘을 쓰면 되겠지 하고 생각해서 열심히 짜고 디버깅도 열심히 했는데 그 알고리즘이 아니게 되면 현타가 좀 온다. 그래서 최근 생긴 습관이 하나 있다. 문제를 읽고 키보드에 손을 올리기 전에 알고리즘을 우선 유추해보는 것이다. 그런 다음 알고리즘 분류를 확인해서 맞으면 코드를 짜고 틀리면 다시 생각한다. 

이 문제는 BFS 인줄 알았다. (이게 아니면 DP 겠지.. 싶었다.) 근데 알고리즘 분류를 보면 애드 혹이었다. 처음보는 알고리즘 분류였고 검색해보니 그냥 규칙 찾아서 풀어내는 알고리즘인 것이다. 애드 혹을 알아채기란 좀 어려운 것 같다. 해결책을 찾아도 긴가민가 하면서 풀게 되는 것 같다. 나는 운이 좋게 규칙을 찾아서 풀었다. 

여기서 a의 1의 개수는 아무리 늘리려고 해도 정해져 있다. 처음 주어지는 1의 개수에서 가장 가까운 짝수 수만큼 1을 가질 수 있다. 0011 이면 최대 2개, 00111이면 최대 4개이다. 즉 a의 최대 1의 개수를 세서, b의 1의 개수와 비교해서 안되면 DEFEAT을 출력하면 된다. 만드는 건 어떻게해서든지 만들 수 있는 모양이다. (그것까지 증명하지는 않고 긴가민가 하면서 풀었는데 맞았다.)</p>

